#include <vector>
#include <iostream>
using namespace std;

template < class T >
BXVector<T>::BXVector( int size,      // number of objects per BX
		    int bxFirst,   // first BX stored
		    int bxLast )  // last BX stored
  :
    bxFirst_(bxFirst),
    bxLast_(bxLast),
    data_(std::vector<T>(size * (bxLast-bxFirst+1)))
{
   itrs_.clear();
   for (int i=0; i<=(bxLast - bxFirst); i++){ 
      itrs_.push_back(i*size);
   }
}

// copy ctor
template < class T >
BXVector<T>::BXVector ( const BXVector& vector )
{
   
}

// dtor
template < class T >
BXVector<T>::~BXVector()
{

}

// assignment operator (pass by value for exception safety)
//template < class T >
//BXVector<T> BXVector<T>::operator=( BXVector vector )
//{
//
//}


// set BX range
template < class T >
void BXVector<T>::setBXRange( int bxFirst, int bxLast )
{
  bxFirst_ = bxFirst;
  bxLast_ = bxLast;
  data_.resize(bxLast-bxFirst+1);
}

// set size for a given BX
template < class T >
void BXVector<T>::resize( int bx, int size )
{
  //data_.at(indexFromBX(bx)).resize(size);
  
}

// set size for all BXs
template < class T >
void BXVector<T>::resizeAll( int size )
{
  for (unsigned i=0; i<data_.size(); ++i) {
    data_.at(i).resize(size);
  }
}

// get the first BX stored
template < class T >
int BXVector<T>::getFirstBX() const
{
  return bxFirst_;
}

// get the last BX stored
template < class T >
int BXVector<T>::getLastBX() const
{
  return bxLast_;
}

// get N objects for a given BX
template < class T >
unsigned BXVector<T>::size( int bx ) const
{
 // return data_.at(indexFromBX(bx)).size();
 //added by team UCD 

   if(isEmpty(bx)){return 0;}

   if(indexFromBX(bx)==(itrs_.size() -1))
     {
     return (data_.size() - itrs_[itrs_.size()-1]);
     }
   
   else
     {
     return (itrs_[indexFromBX(bx+1)] - itrs_[indexFromBX(bx)]);
     }
}


// add element with given BX index
template < class T >
void BXVector<T>::push_back( int bx, T object )
{
   //data_.at(indexFromBX(bx)).push_back(object);

   //added by team UCD 
  if(indexFromBX(bx)==itrs_.size() -1){
    data_.push_back(object);
  }
  else{
      data_.insert(data_.begin() + itrs_[indexFromBX(bx+1)],object);
  }
  for(int k=0; k<itrs_.size();k++){
     if(k >indexFromBX(bx)){
        itrs_[k]++;
     }
  }
 
}


// add clear member
template < class T >
void BXVector<T>::clear()
{
  data_.clear();
  for(int k=0; k<itrs_.size();k++)
     {
        itrs_[k]=0;
     }
}

// add clear member for given bx
template < class T >
void BXVector<T>::clearBX(int bx)
{
  int erased;
  if (isEmpty(bx)==false)
  {
   if (data_.size()==itrs_[indexFromBX(bx)]-1)
     {
     data_.erase(data_.begin()+itrs_[indexFromBX(bx)],data_.end());
     erased = data_.size() - itrs_[indexFromBX(bx)];
     }
   else 
     {
     data_.erase(data_.begin()+itrs_[indexFromBX(bx)],data_.begin()+itrs_[indexFromBX(bx+1)]);
     erased = itrs_[indexFromBX(bx+1)] - itrs_[indexFromBX(bx)];
     }
   for(int k=0; k<itrs_.size();k++){
     if(k >indexFromBX(bx)){
        itrs_[k] = itrs_[k] - erased;
     }
  }
   }
}
// random access
template < class T >
const T& BXVector<T>::at( int bx, int i ) const
{
  return data_.at(indexFromBX(bx)).at(i);
}

// iterator access by BX
template < class T >
typename BXVector<T>::const_iterator BXVector<T>::begin( int bx ) const
{
  return data_.at(indexFromBX(bx)).begin();
}

// iterator access by BX
template < class T >
typename BXVector<T>::const_iterator BXVector<T>::end( int bx ) const
{
  return data_.at(indexFromBX(bx)).end();
}


template < class T >
unsigned BXVector<T>::indexFromBX(int bx) const
{
  return bx - bxFirst_;
}

template <class T>
bool BXVector<T>::isEmpty(int bx) const
{
if (itrs_[indexFromBX(bx)]==itrs_.size()-1)
   {
     if ((data_.size()-1)==itrs_[indexFromBX(bx)])      
        {
	return true;
	}
   }

else
   {
     if (itrs_[indexFromBX(bx)]==itrs_[indexFromBX(bx+1)])
        {
         return true;
        }
   }
return false;
}
