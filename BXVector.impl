#include <vector>
#include <iostream>
using namespace std;

template < class T >
BXVector<T>::BXVector( int size,      // number of objects per BX
		    int bxFirst,   // first BX stored
		    int bxLast )  // last BX stored
  :
    bxFirst_(bxFirst),
    bxLast_(bxLast),
    data_(std::vector<T>(size * (bxLast-bxFirst+1)))
{
   itrs_.clear();
   for (int i=0; i<=(bxLast - bxFirst); i++){ 
      itrs_.push_back(data_.begin() + i*size);
   }
}

// copy ctor
template < class T >
BXVector<T>::BXVector ( const BXVector& vector )
{
   
}

// dtor
template < class T >
BXVector<T>::~BXVector()
{

}

// assignment operator (pass by value for exception safety)
//template < class T >
//BXVector<T> BXVector<T>::operator=( BXVector vector )
//{
//
//}


// set BX range
template < class T >
void BXVector<T>::setBXRange( int bxFirst, int bxLast )
{
  bxFirst_ = bxFirst;
  bxLast_ = bxLast;
  data_.resize(bxLast-bxFirst+1);
}

// set size for a given BX
template < class T >
void BXVector<T>::resize( int bx, int size )
{
  //data_.at(indexFromBX(bx)).resize(size);
  
}

// set size for all BXs
template < class T >
void BXVector<T>::resizeAll( int size )
{
  for (unsigned i=0; i<data_.size(); ++i) {
    data_.at(i).resize(size);
  }
}

// get the first BX stored
template < class T >
int BXVector<T>::getFirstBX() const
{
  return bxFirst_;
}

// get the last BX stored
template < class T >
int BXVector<T>::getLastBX() const
{
  return bxLast_;
}

// get N objects for a given BX
template < class T >
unsigned BXVector<T>::size( int bx ) const
{
 // return data_.at(indexFromBX(bx)).size();

 //added by team UCD 

 if(itrs_.size()==1)
  {return data_.size();}
 else{
    
//cout<<"testShit "<<itrs_[indexFromBX(bx)]-data_.begin()<<endl;

   if(indexFromBX(bx)==(itrs_.size() -1)){
   
   return (data_.end() - itrs_[indexFromBX(bx)]);
   }
   
   else{
     return (itrs_[indexFromBX(bx+1)] - itrs_[indexFromBX(bx)]);
   }
 }
}


// add element with given BX index
template < class T >
void BXVector<T>::push_back( int bx, T object )
{
   //data_.at(indexFromBX(bx)).push_back(object);

   //added by team UCD 
  if(indexFromBX(bx)==itrs_.size() -1){
    data_.push_back(object);
  }
  else{
      cout<<"data: "<<data_.size()<<endl;
      data_.insert(itrs_[indexFromBX(bx+1)],object);
      //typedef typename std::vector<T>::iterator a;
      //a = itrs_.at(indexFromBX(bx));
      //itrs_ = data_.begin();
      //data_.insert(a,1);
      cout<<"dataNew: "<<data_.size()<<endl;
  }
  for(int k=0; k<itrs_.size();k++){
     if(k >indexFromBX(bx)){
        itrs_[k]++;
//	cout<<"testShit2 "<<itrs_[k]-data_.end()<<endl;
     }
  }
 
}

// add clear member
template < class T >
void BXVector<T>::clear()
{
  data_.clear();
}

// random access
template < class T >
const T& BXVector<T>::at( int bx, int i ) const
{
  return data_.at(indexFromBX(bx)).at(i);
}

// iterator access by BX
template < class T >
typename BXVector<T>::const_iterator BXVector<T>::begin( int bx ) const
{
  return data_.at(indexFromBX(bx)).begin();
}

// iterator access by BX
template < class T >
typename BXVector<T>::const_iterator BXVector<T>::end( int bx ) const
{
  return data_.at(indexFromBX(bx)).end();
}


template < class T >
unsigned BXVector<T>::indexFromBX(int bx) const
{
  return bx - bxFirst_;
}

